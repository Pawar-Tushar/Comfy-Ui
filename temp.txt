import User from '../models/user.model.js'; 
import { ApiError } from '../utils/ApiError.js';
import { ApiResponse } from '../utils/ApiResponse.js';
import { asyncHandler } from '../utils/asyncHandler.js';
import Customer from '../models/customer.model.js'; 
import EwasteCentre from '../models/ewaste.model.js';
import Manufacturer from '../models/manufacture.model.js';
import { uploadOnCloudinary } from '../utils/cloudinary.js';



export const getUserProfile = asyncHandler(async (req, res, next) => {
   
    // const userId = req.user._id;
    const {userId} = req.body;
    console.log(userId)
    const user = await User.findById(userId).populate('roleSpecificInfo');
    if (!user) {
        return next(new ApiError(404, "User not found"));
    }
    return res.status(200).json(
        new ApiResponse(200, { user }, "User profile retrieved successfully")
    );
}); 

export const updateGeneralUserProfile = asyncHandler(async (req, res, next) => {

    const {userId} = req.body;
    const { name, phone, email } = req.body; 

    // Check if at least one field is provided
    if (!name && !phone && !email) {
        return next(new ApiError(400, "No fields provided to update"));
    }

    // Create an object to hold the updated fields
    const updatedFields = {};

    // Conditionally add fields to the update object if they are provided
    if (name) updatedFields.name = name;
    if (phone) updatedFields.phone = phone;
    if (email) updatedFields.email = email;

    const updatedUser = await User.findByIdAndUpdate(
        userId,
        {
            $set: updatedFields, // Update only the provided fields
        },
        { new: true, runValidators: true }
    );

    if (!updatedUser) {
        return next(new ApiError(404, "User not found")); 
    }

    return res.status(200).json(
        new ApiResponse(200, { user: updatedUser }, "General profile updated successfully")
    );
});


export const updateRoleSpecificUserProfile = asyncHandler(async (req, res, next) => {

    const userId = req.user._id;
    const userRole = req.user.role;

    const updateData = req.body; 
    let RoleSpecificModel;
    switch (userRole) {
        case 'Customer':
            RoleSpecificModel = Customer;
            break;
        case 'E-Waste Center':
            RoleSpecificModel = EwasteCentre;
            break;
        case 'Manufacturer':
            RoleSpecificModel = Manufacturer;
            break;
        default:
            return next(new ApiError(400, "Invalid user role for profile update")); 
    }

    const user = await User.findById(userId).populate('roleSpecificInfo');
    if (!user || !user.roleSpecificInfo) {
        return next(new ApiError(404, "User or role-specific profile not found"));
    }
    const roleSpecificInfoId = user.roleSpecificInfo._id; 

    const updatedRoleSpecificProfile = await RoleSpecificModel.findByIdAndUpdate(
        roleSpecificInfoId,
        { $set: updateData }, 
        { new: true, runValidators: true } 
    );

    if (!updatedRoleSpecificProfile) {
        return next(new ApiError(500, "Failed to update role-specific profile")); 
    }
    return res.status(200).json(
        new ApiResponse(200, { roleSpecificProfile: updatedRoleSpecificProfile }, "Role-specific profile updated successfully")
    );
}); 

export const updateProfileImage = asyncHandler(async (req, res, next) => {
    // const userId = req.user._id;
    // const userRole = req.user.role;
    const {userId , userRole} = req.body;
    if (!req.file) {
        return next(new ApiError(400, "Image file is required"));
    }


    const cloudinaryResponse = await uploadOnCloudinary(req.file.path);
    if (!cloudinaryResponse || !cloudinaryResponse.url) {
        return next(new ApiError(500, "Failed to upload image to Cloudinary")); 
    }
    const imageUrl = cloudinaryResponse.url; 
    let RoleSpecificModel, imageFieldName;
    switch (userRole) {
        case 'Customer':
            RoleSpecificModel = Customer;
            imageFieldName = 'avatar';
            break;
        case 'E-Waste Center':
            RoleSpecificModel = EwasteCentre;
            imageFieldName = 'centerImage';
            break;
            case 'Manufacturer':
                RoleSpecificModel = Manufacturer;
                imageFieldName = 'companylogo';
                break;
        default:
            return next(new ApiError(400, "Invalid user role for profile image update"));
    }
    const user = await User.findById(userId).populate('roleSpecificInfo');
    if (!user || !user.roleSpecificInfo) {
        return next(new ApiError(404, "User or role-specific profile not found"));
    }
    const roleSpecificInfoId = user.roleSpecificInfo._id;
    const updatedRoleSpecificProfile = await RoleSpecificModel.findByIdAndUpdate(
        roleSpecificInfoId,
        { $set: { [imageFieldName]: imageUrl } }, 
        { new: true } 
    );
    if (!updatedRoleSpecificProfile) {
        return next(new ApiError(500, "Failed to update profile image")); 
    }
    return res.status(200).json(
        new ApiResponse(200, { imageUrl: imageUrl }, "Profile image updated successfully")
    );
});



import express from 'express';
import {
    getUserProfile,
    updateGeneralUserProfile,
    updateRoleSpecificUserProfile,
    updateProfileImage
} from '../controllers/user.controller.js';
import { authenticateToken } from '../middlewares/auth.middleware.js'; 
import { upload } from '../middlewares/multer.middleware.js'; 

const router = express.Router();

// router.use(authenticateToken);

router.route('/profile').get(getUserProfile);

router.route('/profile/general').patch(updateGeneralUserProfile);

router.route('/profile/role-specific').patch(updateRoleSpecificUserProfile);

router.route('/profile/image').patch(upload.single('image'), updateProfileImage);
                    

export default router;










import Order from "../models/order.model.js";
import Item from "../models/item.model.js"; // Assuming you need to check item availability etc.
import User from "../models/user.model.js"; // Import User model
import { ApiError } from "../utils/ApiError.js";
import { ApiResponse } from "../utils/ApiResponse.js";

// --- Create Order ---
export const createOrder = async (req, res, next) => {
    const userId = req.user._id; // Buyer
    const { centerId, items, shippingAddress, billingAddress, paymentMethod } = req.body;

    if (!centerId || !items || !shippingAddress || !billingAddress || !paymentMethod) {
        return next(new ApiError(400, "Missing required order details."));
    }

    try {
        const center = await User.findById(centerId);
        if (!center) {
            return next(new ApiError(400, "Center/Seller not found."));
        }

        if (items.length === 0) {
            return next(new ApiError(400, "No items in the order."));
        }

        let orderItemsDetails = [];
        let totalAmount = 0;

        for (const itemOrder of items) {
            const item = await Item.findById(itemOrder.itemId); // Assuming you pass itemId in items array
            if (!item) {
                return next(new ApiError(400, `Item with ID ${itemOrder.itemId} not found.`));
            }
            if (item.createdBy.toString() !== centerId) { //Basic check if item belongs to the selected center. Enhance this check as needed.
                 return next(new ApiError(400, `Item with ID ${itemOrder.itemId} is not sold by this center.`));
            }
            // **Important:** You'll likely need to add inventory management. Here, you'd check if there's enough stock for the item before adding to the order.  For now, we'll assume stock is available.

            orderItemsDetails.push({
                item: item._id,
                quantity: itemOrder.quantity || 1, // Default to 1 if quantity is not specified
                price: item.price // Using current item price from DB - be careful if prices change frequently
            });
            totalAmount += (item.price * (itemOrder.quantity || 1)); //Calculate total
        }


        const order = new Order({
            user: userId,
            center: centerId,
            items: orderItemsDetails,
            shippingAddress,
            billingAddress,
            paymentMethod,
            totalAmount // Set the calculated total amount
        });

        const savedOrder = await order.save();
        return res.status(201).json(new ApiResponse(201, savedOrder, "Order created successfully."));

    } catch (error) {
        return next(new ApiError(500, "Error creating order: " + error.message));
    }
};


// --- Update Order Status by Center --- (Similar to your `updateRecyclingRequestByCentre`)
export const updateOrderStatusByCenter = async (req, res, next) => {
    const { orderId } = req.params;
    const { status, trackingUpdates } = req.body;

    try {
        const order = await Order.findById(orderId);
        if (!order) {
            return next(new ApiError(404, "Order not found."));
        }

        if (order.center.toString() !== req.user._id.toString()) { // Verify if updating user is the center associated with the order
            return next(new ApiError(403, "Unauthorized to update this order."));
        }

        if (status) {
            order.status = status;
        }
        if (trackingUpdates) {
            order.trackingUpdates.push({
                status: status || order.status, // if status is not sent in tracking update, use the general order status
                updatedAt: new Date(),
                notes: trackingUpdates
            });
        }

        await order.save();
        return res.status(200).json(new ApiResponse(200, order, "Order status updated successfully."));

    } catch (error) {
        return next(new ApiError(500, "Error updating order status: " + error.message));
    }
};

// --- Cancel Order by User --- (Users should be able to cancel in certain statuses, like 'Pending Payment', 'Processing')
export const cancelOrderByUser = async (req, res, next) => {
    const { orderId } = req.params;
    const { cancellationReason } = req.body;

    try {
        const order = await Order.findById(orderId);
        if (!order) {
            return next(new ApiError(404, "Order not found."));
        }

        if (order.user.toString() !== req.user._id.toString()) { // Verify if canceling user is the order user
            return next(new ApiError(403, "Unauthorized to cancel this order."));
        }

        const allowedCancelStatuses = ['Pending Payment', 'Processing']; // Define statuses where cancellation is allowed
        if (!allowedCancelStatuses.includes(order.status)) {
            return next(new ApiError(400, `Order cannot be cancelled in '${order.status}' status. Cancellation allowed only in: ${allowedCancelStatuses.join(', ')}`));
        }

        order.status = 'Cancelled';
        order.cancellationReason = cancellationReason || "Cancelled by user."; // Allow user to give a reason

        await order.save();
        return res.status(200).json(new ApiResponse(200, order, "Order cancelled successfully."));

    } catch (error) {
        return next(new ApiError(500, "Error cancelling order: " + error.message));
    }
};

// --- Get Order Details (by Order ID) ---
export const getOrderById = async (req, res, next) => {
    const { orderId } = req.params;
    try {
        const order = await Order.findById(orderId).populate('user center items.item'); // Populate user, center, and items in order
        if (!order) {
            return next(new ApiError(404, "Order not found."));
        }
        return res.status(200).json(new ApiResponse(200, order, "Order fetched successfully."));
    } catch (error) {
        return next(new ApiError(500, "Error fetching order details: " + error.message));
    }
};


// --- Get Orders for a User (Buyer or Seller - Center) ---
export const getOrdersForUser = async (req, res, next) => {
    const userId = req.user._id; // Current logged-in user
    const userRole = req.user.role; // Assuming you have user roles (e.g., 'endUser', 'center', 'admin') - Adjust as needed
     // Assuming user role is set up, if not you'll need to adjust how you determine if user is center or buyer


    try {
        let query = {};
        if (userRole === 'center') { // If logged-in user is a center, show orders where they are the seller
            query = { center: userId };
        } else { // If logged-in user is an end-user/buyer, show their orders
            query = { user: userId };
        }

        const orders = await Order.find(query).populate('user center items.item'); // Populate relevant fields
        return res.status(200).json(new ApiResponse(200, orders, "Orders fetched successfully."));

    } catch (error) {
        return next(new ApiError(500, "Error fetching orders for user: " + error.message));
    }
};

// You can add more controllers like:
// - getAllOrders (for admin perhaps)
// - getOrdersByStatus (filtering orders)





import RecyclingRequest from "../models/request.model.js";
import { ApiError } from "../utils/ApiError.js";
import { ApiResponse } from "../utils/ApiResponse.js";
import User from "../models/user.model.js"; 


export const createRecyclingRequest = async (req, res, next) => {
    const sender = req.user._id;  // Sender is authenticated via token
    const { receiver, item, pickupDate, pickupTime } = req.body;

    // Validate input fields
    if (!receiver) {
        return next(new ApiError(400, "Receiver is required."));
    }
    if (!item) {
        return next(new ApiError(400, "Item is required."));
    }
    if (!pickupDate || !pickupTime) {
        return next(new ApiError(400, "Pickup Date and Time are required."));
    }

    try {
        const receiverUser = await User.findById(receiver);
        if (!receiverUser) {
            return next(new ApiError(400, "Receiver user does not exist."));
        }

        const itemExist = await Item.findById(item);
        if (!itemExist) {
            return next(new ApiError(400, "Item does not exist."));
        }

        const recyclingRequest = new RecyclingRequest({
            sender,
            receiver,
            item,
            pickupDate,
            pickupTime,
            status: "Pending"  // Default status
        });

        const savedRequest = await recyclingRequest.save();
        return res.status(201).json(new ApiResponse(201, savedRequest, "Recycling request created successfully."));
    } catch (error) {
        return next(new ApiError(500, error.message));
    }
};
export const updateRecyclingRequestByCentre = async (req, res, next) => {
    const { id } = req.params;
    const { status, pickupDate, pickupTime, trackingUpdates } = req.body;

    try {
        const recyclingRequest = await RecyclingRequest.findById(id);
        if (!recyclingRequest) {
            return next(new ApiError(404, "Recycling request not found."));
        }

        // Ensure the user making the update is the Receiver (Centre)
        if (recyclingRequest.receiver.toString() !== req.user._id.toString()) {
            return next(new ApiError(403, "Unauthorized. Only the receiver (Centre) can update the request."));
        }

        // Update the status and pickup time
        if (status) {
            recyclingRequest.status = status;
        }
        if (pickupDate) {
            recyclingRequest.pickupDate = pickupDate;
        }
        if (pickupTime) {
            recyclingRequest.pickupTime = pickupTime;
        }
        if (trackingUpdates) {
            recyclingRequest.trackingUpdates.push({
                status,
                updatedAt: new Date(),
                notes: trackingUpdates
            });
        }

        await recyclingRequest.save();
        return res.status(200).json(new ApiResponse(200, recyclingRequest, "Recycling request updated successfully."));
    } catch (error) {
        return next(new ApiError(500, error.message));
    }
};
export const updateRecyclingRequestByUser = async (req, res, next) => {
    const { id } = req.params;
    const { status, trackingUpdates } = req.body;

    try {
        const recyclingRequest = await RecyclingRequest.findById(id);
        if (!recyclingRequest) {
            return next(new ApiError(404, "Recycling request not found."));
        }

        // Ensure the user making the update is the Sender (End User)
        if (recyclingRequest.sender.toString() !== req.user._id.toString()) {
            return next(new ApiError(403, "Unauthorized. Only the sender can update certain details."));
        }

        if (status) {
            recyclingRequest.status = status;
        }

        if (trackingUpdates) {
            recyclingRequest.trackingUpdates.push({
                status,
                updatedAt: new Date(),
                notes: trackingUpdates
            });
        }

        await recyclingRequest.save();
        return res.status(200).json(new ApiResponse(200, recyclingRequest, "Recycling request updated successfully."));
    } catch (error) {
        return next(new ApiError(500, error.message));
    }
};
export const getAllRecyclingRequests = async (req, res, next) => {
    try {
        const userId = req.user._id;  // Get user from JWT token

        // Fetch recycling requests where the user is either the sender or the receiver
        const recyclingRequests = await RecyclingRequest.find({
            $or: [{ sender: userId }, { receiver: userId }]
        }).populate("sender receiver item");

        return res.status(200).json(new ApiResponse(200, recyclingRequests, "Recycling requests fetched successfully."));
    } catch (error) {
        return next(new ApiError(500, error.message));
    }
};
export const getRecyclingRequestById = async (req, res, next) => {
    const { id } = req.params;

    try {
        const recyclingRequest = await RecyclingRequest.findById(id).populate("sender receiver item");
        if (!recyclingRequest) {
            return next(new ApiError(404, "Recycling request not found."));
        }

        return res.status(200).json(new ApiResponse(200, recyclingRequest, "Recycling request fetched successfully."));
    } catch (error) {
        return next(new ApiError(500, error.message));
    }
};
export const deleteRecyclingRequest = async (req, res, next) => {
    const { id } = req.params;

    try {
        const recyclingRequest = await RecyclingRequest.findById(id);

        if (!recyclingRequest) {
            return next(new ApiError(404, "Recycling request not found."));
        }

        if (recyclingRequest.sender.toString() !== req.user._id.toString() && recyclingRequest.receiver.toString() !== req.user._id.toString()) {
            return next(new ApiError(403, "Unauthorized. Only the sender or receiver can delete the request."));
        }

        await recyclingRequest.remove();
        return res.status(200).json(new ApiResponse(200, null, "Recycling request deleted successfully."));
    } catch (error) {
        return next(new ApiError(500, error.message));
    }
};
